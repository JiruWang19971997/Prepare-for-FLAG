# 二分法
## find solution
### 378. Kth Smallest Element in a Sorted Matrix
- 二维矩阵
按不同条件分成左边和右边（不是不同位置索引）
```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        all_nums = len(matrix) * len(matrix[0])
        if k > all_nums:
            return None
        left, right = matrix[0][0], matrix[-1][-1]
        while left + 1 < right:
            mid = left + (right - left) // 2
            less_num = self.mid_Before(matrix, mid)
            if less_num >= k:
                right = mid
            else:
                left = mid
            print(left, right)
        if self.mid_Before(matrix, left) >= k:  # 存在重复数字，取其中一个即可（13， 13， 13，停在第二个13上）
            return left
        else:
            return right
        
    def mid_Before(self, matrix, mid):
        i, j = len(matrix) - 1, 0
        less = 0
        
        while i >= 0 and j < len(matrix[0]):
            if matrix[i][j] <= mid: # 向右一步
                less += 1
                less += i # 起始点之前，没算的
                j += 1
            else: # 向上一步
                i -= 1
        return less
            
```
### 287. Find the Duplicate Number
每个位置需有一个
```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # [1, 2, 3, 4]
        # [1, 2, 2, 3, 4]
        n = len(nums) - 1 
        left, right = 1, n
        while left + 1 < right:
            mid = left + (right - left) // 2
            less_cnt = self.get_Less(nums, mid)
            if less_cnt > mid:
                right = mid
            else:
                left = mid
        if self.get_Less(nums, left) > left:
            return left
        if self.get_Less(nums, right) > right:
            return right
        return 0
    def get_Less(self, nums, target):
        cnt = 0
        for num in nums:
            if num > target:
                continue
            cnt += 1
        return cnt
```




## 二分法mid跟前后问题
### 34. Find First and Last Position of Element in Sorted Array
```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0 or not nums:
            return [-1, -1]
        # first
        left = self.find_first_position(nums, target)
        # end
        right = self.find_last_position(nums, target)
        
        return [left, right]
    
    def find_first_position(self, nums, target):
        left, right = 0, len(nums) - 1
        while left + 1 < right:
            mid = left + (right - left) // 2
            if nums[mid] >= target:
                right = mid
            else:
                left = mid
        if nums[left] == target:
            return left
        if nums[right] == target:
            return right
        return -1
    
    def find_last_position(self, nums, target):
        left, right = 0, len(nums) - 1
        while left + 1 < right:
            mid = left + (right - left) // 2
            if nums[mid] <= target:
                left = mid
            else:
                right = mid
        if nums[right] == target:
            return right
        if nums[left] == target:
            return left
        return -1
```
### 278. First Bad Version
```python
# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:
class Solution:
    def firstBadVersion(self, n: int) -> int:
        if n == 1:
            return 1
        # f, f, t, t, t, t
        left, right = 1, n
        while left + 1 < right:
            mid = left + (right - left) // 2
            if not isBadVersion(mid):
                left = mid
            else:
                right = mid
        if isBadVersion(left):
            return left
        if isBadVersion(right):
            return right
        return right
```
