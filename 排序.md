### 时间复杂度
快排：max:n^2, avg nlogn   
归并：nlogn(更稳定)
### 空间复杂度
快排：O1
归并：On  

### 快排
```python
from typing import (
    List,
)

class Solution:
    """
    @param k: An integer
    @param nums: An array
    @return: the Kth largest element
    """
    def kthLargestElement(self, k, nums):
        p =self.test(nums)
        print(p)
        
    def test(self,A):
        if len(A) <=1 :
            return A
        middle = len(A) // 2 
        A1 = A[:middle]
        A2 = A[middle:]
        self.test(A1)
        self.test(A2)
        print(A1,A2)     
        print(A) 
        k = 0
        while len(A1) and len(A2):
            if A1[0] < A2[0]: 
                A[k]=A1.pop(0)
            else: 
                A[k]=A2.pop(0)
            k = k + 1

        while len(A1):
            A[k] = A1.pop(0)
            k = k + 1
        while len(A2):
            A[k] = A2.pop(0)
            k = k + 1
        return A
```
### 归并
```python
class Solution:
    """
    @param a: an integer array
    @return: nothing
    """
    def sortIntegers2(self, A):
        if len(A) <= 1:
            print('return')
            print(A)
            return A
        middle = len(A) // 2 
        A1 = A[:middle]
        A2 = A[middle:]
        self.sortIntegers2(A1)
        self.sortIntegers2(A2)        
        k = 0
        while len(A1) and len(A2):
            if A1[0] < A2[0]: 
                A[k]=A1.pop(0)
            else: 
                A[k]=A2.pop(0)
            k = k + 1

        while len(A1):
            A[k] = A1.pop(0)
            k = k + 1
        while len(A2):
            A[k] = A2.pop(0)
            k = k + 1
        print(A)
```
### 5 · Kth Largest Element
log(n)


```python
from typing import (
    List,
)

class Solution:
    """
    @param k: An integer
    @param nums: An array
    @return: the Kth largest element
    """
    def kthLargestElement(self, k, nums):
        n = len(nums)
        k = n - k
        return self.partition(nums, 0, n - 1, k)
    
    def partition(self, nums, start, end, k):
        left, right = start, end
        pivot = nums[left]
        
        while left <= right:
            while left <= right and nums[left] < pivot:
                left += 1
            while left <= right and nums[right] > pivot:
                right -= 1
            if left <= right:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
                right -= 1
        print('before')
        print(pivot)
        print(nums)
        print((left,right))
        print('-------------------')
        # 如果第 k 小在右侧，搜索右边的范围，否则搜索左侧。
        if k <= right:
            return self.partition(nums, start, right, k)
        if k >= left:
            return self.partition(nums, left, end, k)
        print(nums)
        print((left,right))
        
        return nums[k]
```
